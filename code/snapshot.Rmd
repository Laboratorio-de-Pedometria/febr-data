---
output: html_document
---

```{r}
library(magrittr)
library(dplyr)
library(googlesheets)
library(sf)
library(febr)
```

Descarregar e pós-processar (padronização e harmonização) versão corrente de um conjunto de doze variáveis
disponíveis no ___febr___. São elas:

* Tabela `observacao`:
  - Classificação taxonômica pelo Sistema Brasileiro de Classificação do Solo (`taxon_sibcs`)
  - Classificação taxonômica pelo Soil Taxonomy (`taxon_st`)
  - Classificação taxonômica pelo World Reference Base for Soil Resources (`taxon_wrb`)
* Tabela `camada`:
  - Conteúdo de fração terra fina (< 2 mm) no solo inteiro, em g/kg (`terrafina`)
  - Conteúdo de carbono orgânico na fração terra fina, em g/kg (`carbono`)
  - Conteúdo de argila total na fração terra fina, em g/kg (`argila`)
  - Conteúdo de silte total na fração terra fina, em g/kg (`silte`)
  - Conteúdo de areia total na fração terra fina, em g/kg (`areia`)
  - Capacidade de troca de cátions da fração terra fina, em cmol~c~/kg (`ctc`)
  - pH em água da fração terra fina (`ph`)
  - Condutividade elétrica de fração terra fina, em mS/cm (`ce`)
  - Densidade do solo inteiro, em kg/dm^3^ (`dsi`)

A maioria dos passos de padronização e harmonização dos dados estão descritos na página do pacote `febr` para
o R em https://febr-team.github.io/febr-package/. Os dados são disponibilizados ao público usando o formato 
universal CSV no repositório do ___febr___ no GitHub em https://github.com/febr-team/febr-data/tree/master/data.

## Tabelas `observacao`

```{r}
vars <- "taxon_"
observacao <- observation(
  dataset = "all", 
  variable = vars, 
  stack = TRUE, 
  standardization = list(
    crs =  "EPSG:4674", 
    time.format = "%d-%m-%Y", 
    units = FALSE, round = FALSE),
  harmonization = list(harmonize = TRUE, level = 3))
```

### Classificação taxonômica

O processamento dos dados de classificação taxonômica segue os seguintes passos:

1. Fusão das colunas `taxon_sibcs_<...>` em uma única coluna `taxon_sibcs` usando `dplyr::coalesce()`, dando
   prioridade à classificação mais recente. Por enquanto, a classificação antiga (antes de 1999) é ignorada, 
   pois a nomenclatura utilizada é muito diferente da nomenclatura atual. Nesse caso, observações apenas com a
   classificação taxonômica antiga do SiBCS ficam sem dados (`NA_character`) na nova coluna `taxon_sibcs`.
2. Substituição da classificação taxonômica no SiBCS registrada na forma de sigla pelo nome correspondente por
   extenso usando `dplyr::recode()`.
3. Eliminação do terceiro e quarto níveis categóricos da classificação taxonômica do SiBCS usando
   `base::strsplit()`.
4. Formatação da classificação taxonômica no SiBCS em caixa alta.
5. Fusão das colunas `taxon_st_<...>` e `taxon_wrb_<...>` em uma única coluna `taxon_st` e `taxon_wrb`, 
   respectivamente, dando prioridade à classificação mais recente. Diferente da classificação taxonômica no
   SiBCS, aqui as classificações antigas não são ignoradas.

```{r}
sibcs_tabela <- 
  "1yJ_XnsJhnhJSfC3WRimfu_3_owXxpfSKaoxCiMD2_Z0" %>% 
  gs_key %>% 
  gs_read_csv()
sibcs_siglas <- sibcs_tabela$campo_codigo
sibcs_tabela <- as.list(sibcs_tabela$campo_nome)
names(sibcs_tabela) <- sibcs_siglas
observacao <- 
  observacao %>% 
  mutate(
    taxon_sibcs = dplyr::coalesce(
      taxon_sibcs_2013, taxon_sibcs_2009, taxon_sibcs_2006, taxon_sibcs_2003, taxon_sibcs_1999),
      # taxon_sibcs_19xx, taxon_sibcs_xxx, taxon_sibcs_xxx_1, taxon_sibcs_xxx_2, taxon_sibcs_xxxx),
    taxon_sibcs = dplyr::recode(.data$taxon_sibcs, !!!sibcs_tabela),
    taxon_sibcs = sapply(
      .data$taxon_sibcs, function (x) strsplit(x, " ")[[1]][1:2] %>% paste(collapse = " ")) %>% as.character,
    taxon_sibcs = gsub(pattern = "NA NA", NA_character_, .data$taxon_sibcs),
    taxon_sibcs = toupper(taxon_sibcs)) %>% 
  mutate(
    taxon_st = coalesce(taxon_st_2010, taxon_st_1999, taxon_st_xxx),
    taxon_wrb = coalesce(taxon_wrb_2006, taxon_wrb_1998, taxon_wrb_xxx))
```

### Organização das colunas

As colunas são organizadas usando `dplyr::select()` de maneira a:

1. Descartar as colunas `taxon_sibcs_<...>`, `taxon_st_<...>` e `taxon_wrb_<...>`, processadas acima e 
   substituidas pelas colunas `taxon_sibcs`, `taxon_st` e `taxon_wrb`, respectivamente.
2. Descartar a colunas `coord_sistema`, uma vez que as coordenadas espaciais de todas as observações foram
   padronizadas para o sistema de referência de coordenadas SIRGAS 2000 (EPSG:4674).
3. Posicionar as colunas com dados de identificação -- `observacao_id_`, `sisb_id` e `ibge_id` lado-a-lado.

O tipo de dados das colunas também é definido aqui:

1. Os dados da coluna `coord_precisao` são definidos como do tipo real usando `as.numeric()`.

```{r}
observacao %<>%
  dplyr::select(
    dataset_id, observacao_id, sisb_id, ibge_id, observacao_data, coord_x, coord_y, coord_precisao, 
    coord_fonte, pais_id, estado_id, municipio_id, amostra_tipo, amostra_quanti, amostra_area, taxon_sibcs, 
    taxon_st, taxon_wrb) %>% 
  dplyr::mutate(
    coord_precisao = as.numeric(coord_precisao))
```

```{r}
head(observacao)
```

### Figuras

Verificar distribuição espacial das observações.

```{r}
png("../res/febr-observacao-espaco.png", width = 480 * 2, height = 480 * 2, res = 72 * 2)
observacao %>% 
  filter(!is.na(coord_x) | !is.na(coord_y)) %>% 
  st_as_sf(coords = c('coord_x', 'coord_y'), crs = 4674) %>%
  dplyr::select(pais_id) %>% 
  plot(
    cex = 0.5, col = "firebrick", axes = TRUE, 
    graticule = TRUE, main = glue::glue("{Sys.Date()}-febr-observacao"))
dev.off()
```

Verificar temporal espacial das observações.

```{r}
png("../res/febr-observacao-tempo.png", width = 480 * 2, height = 480 * 2, res = 72 * 2)
tmp <- 
  observacao$observacao_data %>%
  as.Date() %>% 
  format("%Y") %>% 
  table()
barplot(tmp, col = "firebrick", border = "firebrick")
grid()
barplot(
  tmp, col = "firebrick", border = "firebrick", add = TRUE, xlab = "Ano", ylab = "Número de observações",
  main = glue::glue("{Sys.Date()}-febr-observacao"))
dev.off()
```

### Salvar dados

Salvar os dados no formato CSV.

```{r}
write.table(
  observacao, file = glue::glue("../data/febr-observacao.csv"), sep = ";", dec = ",", row.names = FALSE)
```

## Tabelas `camada`

```{r}
vars <- c(
  "carbono",
  "argila", "areia", "areiagrossa", "areiafina", "silte",
  "terrafina", "cascalho", "calhaus",
  "dsi",
  "ctc",
  "ph",
  "ce")
camada <- febr::layer(
  dataset = "all",
  variable = glue::glue("{vars}_"),
  stack = TRUE,
  harmonization = list(harmonize = TRUE, level = 2),
  standardization = list(
    plus.sign = "add",
    plus.depth = 20,
    lessthan.sign = "remove",
    # lessthan.frac = 0.5,
    repetition = "keep", 
    # combine.fun = "mean",
    transition = "smooth",
    smoothing.fun = "mean",
    units = TRUE, round = TRUE))
```

### Processamento dos dados

O processamento dos dados das variáveis prioritárias das tabelas `camada` segue os seguintes passos:

1. Valores de pH (`ph_<...>`) são sequencialmente divididos por constantes a fim de que se encontrem no 
   intervalo de 0 a 14.
2. Valores de profundidade questionáveis, como 9999 e 999, são substituídos por `NA_real_`.
3. Valores de conteúdo de argila total, silte total e areia total na fração terra fina superiores a 1000 g/kg 
   são divididos pelas constantes 100 e/ou 10, conforme a necessidade.
4. Valores de densidade do solo inteiro superiores a 3 kg/dm^3^ são divididos pelas constantes 100 e/ou 10,
   conforme a necessidade.

```{r}
cols <- colnames(camada)

# pH
ph <- grep("^ph_", cols)
if (length(ph) >= 1) {
  ph_idx <- which(camada[, ph] > 1000, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 100
  }
  ph_idx <- which(camada[, ph] > 100, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 100
  }
  ph_idx <- which(camada[, ph] > 14, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 10
  }
}

# Profundidade
profund <- grep("^profund_", cols)
profund_idx <- which(camada[, profund] == 9999, arr.ind = TRUE)
camada[, profund][profund_idx] <- NA_real_
profund_idx <- which(camada[, profund] == 999, arr.ind = TRUE)
camada[, profund][profund_idx] <- NA_real_

# Argila
argila <- grep("^argila_", cols)
if (length(argila) >= 1) {
  argila_idx <- which(camada[, argila] > 1000, arr.ind = TRUE)
  if (length(argila_idx) >= 1) {
    camada[, argila][argila_idx] <- camada[, argila][argila_idx] / 10
  }
}

# Areia
areia <- grep("^areia", cols)
if (length(areia) >= 1) {
  areia_idx <- which(camada[, areia] > 10000, arr.ind = TRUE)
  if (length(areia_idx) >= 1) {
    camada[, areia][areia_idx] <- camada[, areia][areia_idx] / 100
  }
  areia_idx <- which(camada[, areia] > 1000, arr.ind = TRUE)
  if (length(areia_idx) >= 1) {
    camada[, areia][areia_idx] <- camada[, areia][areia_idx] / 10
  }
}

# Silte
silte <- grep("^silte_", cols)
if (length(silte) >= 1) {
  silte_idx <- which(camada[, silte] > 1000, arr.ind = TRUE)
  if (length(silte_idx) >= 1) {
    camada[, silte][silte_idx] <- camada[, silte][silte_idx] / 10
  }
}

# DSI
dsi <- grep("^dsi_", cols)
if (length(dsi) >= 1) {
  dsi_idx <- which(camada[, dsi] > 30, arr.ind = TRUE)
  if (length(dsi_idx) >= 1) {
    camada[, dsi][dsi_idx] <- camada[, dsi][dsi_idx] / 100
  }
  dsi_idx <- which(camada[, dsi] > 3, arr.ind = TRUE)
  if (length(dsi_idx) >= 1) {
    camada[, dsi][dsi_idx] <- camada[, dsi][dsi_idx] / 10
  }
}
```

Em seguida, as colunas dos dados de cada variável prioritária determinadas usando métodos parcialmente
distintos são fundidas usando usando `dplyr::coalesce()`.

```{r}
camada %<>% 
  dplyr::mutate(
    carbono = dplyr::coalesce(carbono_cromo, carbono_xxx, carbono_forno),
    argila = dplyr::coalesce(argila_naoh, argila_xxx),
    silte = dplyr::coalesce(silte_naoh, silte_xxx),
    areia = dplyr::coalesce(areia_naoh, areia_xxx),
    areiagrossa = dplyr::coalesce(areiagrossa_naoh, areiagrossa_xxx),
    areiafina = dplyr::coalesce(areiafina_naoh, areiafina_xxx),
    ctc = dplyr::coalesce(ctc_soma, ctc_xxx),
    dsi = dplyr::coalesce(dsi_cilindro, dsi_xxx),
    ph = dplyr::coalesce(ph_h2o),
    terrafina = dplyr::coalesce(terrafina_peneira, terrafina_xxx),
    ce = dplyr::coalesce(ce_pastasat),
    cascalho = dplyr::coalesce(cascalho_peneira, cascalho_olho, cascalho_xxx),
    calhau = dplyr::coalesce(calhaus_peneira, calhaus_xxx)
  ) %T>% 
  print()
```

Após a fusão das colunas com dados da mesma variável, faz-se ajustes nos dados das frações granulométricas. 
Primeiro, na falta de uma das duas frações granulométricas finas, `argila` ou `silte`, calcula-se seu valor 
como sendo a diferença entre 1000 g/kg e a soma das duas outras frações granulométricas. Na falta dos dados do
conteúdo de areia total -- `areia`, primeiro se usa (quando disponível) a soma dos dados do conteúdo de areia
grossa -- `areiagrossa` -- e areia fina `areiafina`. Caso não estejam disponíveis, então se usa a estratégia 
anterior. A seguir, verifica-se se a soma dos valores inteiros das três frações é igual a 1000 g/kg. Caso não 
seja -- a diferença geralmente é de 1 g/kg para menos ou para mais --, então altera-se os dados do conteúdo de
silte total de maneira que a soma seja igual a 1000 g/kg. Finalmente, faz-se o processamento dos dados das
frações granulométricas grossas calhau -- `calhau` --, cascalho -- `cascalho` -- e terra fina -- `terrafina`.
na ausência da última, utiliza-se as demais para sua estimativa. Caso todas as frações estejam faltando, então
assume-se que o conteúdo da fração terra fina seja igual a 1000 g/kg. Isso porque é comum os trabalhos omitirem
o conteúdo de terra fina quando a mesma corresponde a totalidade do solo.

```{r}
camada %<>% 
  dplyr::mutate(
    argila_in = !is.na(argila),
    silte_in = !is.na(silte),
    areia_in = !is.na(areia),
    dtp = argila_in + silte_in + areia_in,
    argila = ifelse(dtp == 2 & !argila_in, 1000 - areia - silte, argila),
    silte = ifelse(dtp == 2 & !silte_in, 1000 - argila - areia, silte),
    areia = ifelse(!argila_in, areiagrossa + areiafina, areia),
    areia_in = !is.na(areia),
    areia = ifelse(dtp == 2 & !areia_in, 1000 - argila - silte, areia),
    dtp = areia + argila + silte,
    argila = round((argila / dtp) * 1000),
    silte = round((silte / dtp) * 1000),
    areia = round((areia / dtp) * 1000),
    dtp = areia + argila + silte,
    silte = ifelse(dtp != 1000, 1000 - areia - argila, silte),
    terrafina_in = !is.na(terrafina),
    cascalho_in = !is.na(cascalho),
    calhau_in = !is.na(calhau),
    terrafina = ifelse(!terrafina_in & cascalho_in & calhau_in, 1000 - cascalho - calhau, terrafina),
    terrafina = ifelse(!terrafina_in & cascalho_in, 1000 - cascalho, terrafina),
    terrafina = ifelse(!terrafina_in & calhau_in, 1000 - calhau, terrafina),
    terrafina = ifelse(!terrafina_in & !cascalho_in & !calhau_in, 1000, terrafina) %>% round()
  )
```

A última etapa de processamento lida com os dados da profundidade do solo, especificamente, com as camadas
compostas por material orgânico. Em geral, o registro dessas camadas é realizado fixando o limite inferior como
sendo igual a zero. Isso gera uma sequência invertida de valores de profundidade. Por exemplo, uma camada com 
profundidade de 3--0 cm representa uma camada orgânica de três centímetros de espessura na superfície do solo. 
Em alguns casos a profundidade superior pode ser negativa, por exemplo, -3--0 cm. O processamento desses dados
consiste em somar o valor da maior (menor, quando negativa) profundidade superior a todos os valores de 
profundidade daquela observação.

```{r}
camada %>% 
  dplyr::mutate(
    profund_sup = abs(profund_sup),
    profund_inf = abs(profund_inf)
  ) %>% 
  dplyr::filter(profund_sup > profund_inf & dataset_id != "ctb0032") %>%
  dplyr::select(dataset_id, observacao_id, camada_nome, profund_sup, profund_inf, argila)
  # dplyr::mutate(profund_sup = round(profund_sup)) %>% 
  
```

```{r}
febr::goto("ctb0646")
```


```{r}
# camada <- dplyr::select(
#   camada, 
#   dataset_id, observacao_id, camada_id, amostra_id, camada_nome, profund_sup, profund_inf,
#   terrafina, argila, silte, areia, carbono, ctc, ph, dsi, ce)
```


Verificar a distribuição empírica dos dados, procurando por insconsistências nos dados.

```{r}
png("../res/febr-camada.png", width = 480 * 2, height = 480 * 2, res = 72 * 2)
camada %>% 
  rename(profund = profund_inf) %>%
  select(profund, carbono, argila, areia, silte, terrafina, dsi, ctc, ph, ce) %>% 
  plot(cex = 0.5, col = "firebrick", main = glue::glue("{Sys.Date()}-febr-camada"))
dev.off()
```

Salvar os dados no formato CSV.

```{r}
write.table(camada, file = glue::glue("../data/febr-camada.csv"), sep = ";", dec = ",", row.names = FALSE)
```

## Tabelas `observacao` + `camada`

```{r}
febr <- merge(observacao, camada, by = c("dataset_id", "observacao_id"))
write.table(febr, file = "../data/febr-superconjunto.csv", sep = ";", dec = ",", row.names = FALSE)
```
