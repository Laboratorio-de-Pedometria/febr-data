---
output: html_document
---

```{r}
library(magrittr)
library(dplyr)
library(googlesheets)
library(sf)
library(febr)
```

Descarregar e pós-processar versão corrente de um conjunto de prioritárias variáveis disponíveis no ___febr___.
Os dados são disponibilizados ao público usando diferentes formatos.

## Tabelas `observacao`

```{r}
vars <- "taxon_"
observacao <- observation(
  dataset = "all", 
  variable = vars, 
  stack = TRUE, 
  standardization = list(
    crs =  "EPSG:4674", 
    time.format = "%d-%m-%Y", 
    units = FALSE, round = FALSE),
  harmonization = list(harmonize = TRUE, level = 3))
```

```{r}
# colnames(observacao)[grepl("taxon_sibcs", colnames(observacao))]
# colnames(observacao)[grepl("taxon_st", colnames(observacao))]
# colnames(observacao)[grepl("taxon_wrb", colnames(observacao))]
sibcs_tabela <- 
  "1yJ_XnsJhnhJSfC3WRimfu_3_owXxpfSKaoxCiMD2_Z0" %>% 
  gs_key %>% 
  gs_read_csv()
sibcs_siglas <- sibcs_tabela$campo_codigo
sibcs_tabela <- as.list(sibcs_tabela$campo_nome)
names(sibcs_tabela) <- sibcs_siglas
observacao <- 
  observacao %>% 
  mutate(
    taxon_sibcs = coalesce(
      taxon_sibcs_2013, taxon_sibcs_2009, taxon_sibcs_2006, taxon_sibcs_2003, taxon_sibcs_1999),
      # Por enquanto, ignora classificação antiga
      # taxon_sibcs_19xx, taxon_sibcs_xxx, taxon_sibcs_xxx_1, taxon_sibcs_xxx_2, taxon_sibcs_xxxx),
    taxon_sibcs = recode(.data$taxon_sibcs, !!!sibcs_tabela),
    taxon_sibcs = sapply(
      .data$taxon_sibcs, function (x) strsplit(x, " ")[[1]][1:2] %>% paste(collapse = " ")) %>% as.character,
    taxon_sibcs = gsub(pattern = "NA NA", NA_character_, .data$taxon_sibcs),
    taxon_sibcs = toupper(taxon_sibcs)) %>% 
  select(-starts_with("taxon_sibcs_")) %>% 
  mutate(
    taxon_st = coalesce(taxon_st_2010, taxon_st_1999, taxon_st_xxx),
    taxon_wrb = coalesce(taxon_wrb_2006, taxon_wrb_1998, taxon_wrb_xxx)) %>% 
  select(-starts_with("taxon_st_")) %>% 
  select(-starts_with("taxon_wrb_"))
```

```{r}
head(observacao)
```

Verificar distribuição espacial das observações com coordenadas espaciais e salvar figura para divulgação.

```{r}
tmp <- 
  observacao %>% 
  filter(!is.na(coord_x) | !is.na(coord_y)) %>% 
  st_as_sf(coords = c('coord_x', 'coord_y'), crs = 4674)
png("../res/febr-observacao.png", width = 480 * 2, height = 480 * 2, res = 72 * 2)
plot(
  tmp["pais_id"], cex = 0.5, colorkey = FALSE, col = "firebrick", axes = TRUE, 
  graticule = TRUE, main = glue::glue("{Sys.Date()}-febr-observacao"))
dev.off()
```

Salvar os dados no formato CSV.

```{r}
write.table(
  observacao, file = glue::glue("../data/febr-observacao.csv"), sep = ";", dec = ",", row.names = FALSE)
```

## Tabelas `camada`

```{r}
vars <- c("carbono", "argila", "areia", "silte", "terrafina", "dsi", "ctc", "ph", "ce")
camada <- febr::layer(
  dataset = "all",
  variable = glue::glue("{vars}_"),
  stack = TRUE,
  harmonization = list(harmonize = TRUE, level = 2),
  standardization = list(
    plus.sign = "remove", lessthan.sign = "remove",
    lessthan.sign = "remove",
    repetition = "combine", combine.fun = "mean",
    transition = "smooth", smoothing.fun = "mean",
    units = TRUE, round = TRUE))
```

Corrigir valores fora do intervalo real.

```{r}
cols <- colnames(camada)

# pH
ph <- grep("^ph_", cols)
if (length(ph) >= 1) {
  ph_idx <- which(camada[, ph] > 1000, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 100
  }
  ph_idx <- which(camada[, ph] > 100, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 100
  }
  ph_idx <- which(camada[, ph] > 14, arr.ind = TRUE)
  if (length(ph_idx) >= 1) {
    camada[, ph][ph_idx] <- camada[, ph][ph_idx] / 10
  }
}

# Profundidade
profund <- grep("^profund_", cols)
profund_idx <- which(camada[, profund] == 9999, arr.ind = TRUE)
camada[, profund][profund_idx] <- NA_real_
profund_idx <- which(camada[, profund] == 999, arr.ind = TRUE)
camada[, profund][profund_idx] <- NA_real_

# Argila
argila <- grep("^argila_", cols)
if (length(argila) >= 1) {
  argila_idx <- which(camada[, argila] > 1000, arr.ind = TRUE)
  if (length(argila_idx) >= 1) {
    camada[, argila][argila_idx] <- camada[, argila][argila_idx] / 10
  }
}

# Areia
areia <- grep("^areia", cols)
if (length(areia) >= 1) {
  areia_idx <- which(camada[, areia] > 10000, arr.ind = TRUE)
  if (length(areia_idx) >= 1) {
    camada[, areia][areia_idx] <- camada[, areia][areia_idx] / 100
  }
  areia_idx <- which(camada[, areia] > 1000, arr.ind = TRUE)
  if (length(areia_idx) >= 1) {
    camada[, areia][areia_idx] <- camada[, areia][areia_idx] / 10
  }
}

# Silte
silte <- grep("^silte_", cols)
if (length(silte) >= 1) {
  silte_idx <- which(camada[, silte] > 1000, arr.ind = TRUE)
  if (length(silte_idx) >= 1) {
    camada[, silte][silte_idx] <- camada[, silte][silte_idx] / 10
  }
}

# DSI
dsi <- grep("^dsi_", cols)
if (length(dsi) >= 1) {
  dsi_idx <- which(camada[, dsi] > 30, arr.ind = TRUE)
  if (length(dsi_idx) >= 1) {
    camada[, dsi][dsi_idx] <- camada[, dsi][dsi_idx] / 100
  }
  dsi_idx <- which(camada[, dsi] > 3, arr.ind = TRUE)
  if (length(dsi_idx) >= 1) {
    camada[, dsi][dsi_idx] <- camada[, dsi][dsi_idx] / 10
  }
}
```

Pós-processamentos das variáveis prioritárias.

```{r}
rowMedians <-
  function (x) {
    apply(x, MARGIN = 1, median, na.rm = TRUE)
  }
camada$carbono <- rowMedians(camada[c("carbono_cromo", "carbono_forno", "carbono_xxx")])
camada$argila <- rowMedians(dplyr::select(camada, argila_naoh, argila_xxx))
camada$areia <- rowMedians(dplyr::select(camada, areia_naoh, areia_xxx))
camada$silte <- rowMedians(dplyr::select(camada, silte_naoh, silte_xxx))
camada$dsi <- rowMedians(dplyr::select(camada, dsi_cilindro, dsi_xxx))
camada$ctc <- rowMedians(dplyr::select(camada, ctc_xxx, ctc_soma))
camada$ph <- rowMedians(dplyr::select(camada, ph_h2o))
camada$terrafina <- rowMedians(dplyr::select(camada, terrafina_xxx, terrafina_peneira))
camada$ce <- rowMedians(dplyr::select(camada, ce_pastasat))
camada[c("argila", "areia", "silte")] <- 
  camada[c("argila", "areia", "silte")] / rowSums(camada[c("argila", "areia", "silte")]) * 1000
camada[which(camada$terrafina == 0), vars] <- NA_real_
camada[which(camada$dsi == 0), c("dsi")] <- NA_real_
# camada <- camada[rowSums(is.na(camada[vars])) < length(vars), ] # filtra observações sem dados
camada <- dplyr::select(
  camada, 
  dataset_id, observacao_id, camada_id, amostra_id, camada_nome, profund_sup, profund_inf,
  terrafina, argila, silte, areia, carbono, ctc, ph, dsi, ce)
```

Verificar a distribuição empírica dos dados, procurando por insconsistências nos dados.

```{r}
png("../res/febr-camada.png", width = 480 * 2, height = 480 * 2, res = 72 * 2)
camada %>% 
  rename(profund = profund_inf) %>%
  select(profund, carbono, argila, areia, silte, terrafina, dsi, ctc, ph, ce) %>% 
  plot(cex = 0.5, col = "firebrick", main = glue::glue("{Sys.Date()}-febr-camada"))
dev.off()
```

Salvar os dados no formato CSV.

```{r}
write.table(camada, file = glue::glue("../data/febr-camada.csv"), sep = ";", dec = ",", row.names = FALSE)
```

## Tabelas `observacao` + `camada`

```{r}
febr <- merge(observacao, camada, by = c("dataset_id", "observacao_id"))
write.table(febr, file = "../data/febr-superconjunto.csv", sep = ";", dec = ",", row.names = FALSE)
```
